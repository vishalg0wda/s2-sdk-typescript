/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { EventStream } from "../../lib/event-streams.js";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export const ReadServerList = [
  /**
   * Endpoint for the basin
   */
  "https://{basin}.b.aws.s2.dev/v1",
] as const;

export type ReadRequest = {
  /**
   * Stream name.
   */
  stream: string;
  /**
   * Define treatment of blob fields when exchanging records as JSON.
   *
   * @remarks
   * The default is `raw`.
   */
  s2Format?: components.S2Format | undefined;
  /**
   * Start from a sequence number.
   */
  seqNum?: number | undefined;
  /**
   * Start from a timestamp.
   */
  timestamp?: number | undefined;
  /**
   * Start from number of records before the tail, i.e. before the next sequence number.
   */
  tailOffset?: number | undefined;
  /**
   * Limit total records to return.
   *
   * @remarks
   * If this is provided, tailing will be disabled.
   */
  count?: number | undefined;
  /**
   * Limit total metered bytes to return.
   *
   * @remarks
   * If this is provided, tailing will be disabled.
   */
  bytes?: number | undefined;
  /**
   * Exclusive timestamp to read until.
   *
   * @remarks
   * If this is provided, tailing will be disabled.
   */
  until?: number | undefined;
  /**
   * Basin name for basin-specific endpoints
   */
  s2Basin: string;
};

export type ReadResponse =
  | components.ReadBatch
  | EventStream<components.ReadEvent>;

/** @internal */
export const ReadRequest$inboundSchema: z.ZodType<
  ReadRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  stream: z.string(),
  "s2-format": components.S2Format$inboundSchema.optional(),
  seq_num: z.number().int().optional(),
  timestamp: z.number().int().optional(),
  tail_offset: z.number().int().optional(),
  count: z.number().int().optional(),
  bytes: z.number().int().optional(),
  until: z.number().int().optional(),
  "s2-basin": z.string(),
}).transform((v) => {
  return remap$(v, {
    "s2-format": "s2Format",
    "seq_num": "seqNum",
    "tail_offset": "tailOffset",
    "s2-basin": "s2Basin",
  });
});

/** @internal */
export type ReadRequest$Outbound = {
  stream: string;
  "s2-format"?: string | undefined;
  seq_num?: number | undefined;
  timestamp?: number | undefined;
  tail_offset?: number | undefined;
  count?: number | undefined;
  bytes?: number | undefined;
  until?: number | undefined;
  "s2-basin": string;
};

/** @internal */
export const ReadRequest$outboundSchema: z.ZodType<
  ReadRequest$Outbound,
  z.ZodTypeDef,
  ReadRequest
> = z.object({
  stream: z.string(),
  s2Format: components.S2Format$outboundSchema.optional(),
  seqNum: z.number().int().optional(),
  timestamp: z.number().int().optional(),
  tailOffset: z.number().int().optional(),
  count: z.number().int().optional(),
  bytes: z.number().int().optional(),
  until: z.number().int().optional(),
  s2Basin: z.string(),
}).transform((v) => {
  return remap$(v, {
    s2Format: "s2-format",
    seqNum: "seq_num",
    tailOffset: "tail_offset",
    s2Basin: "s2-basin",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReadRequest$ {
  /** @deprecated use `ReadRequest$inboundSchema` instead. */
  export const inboundSchema = ReadRequest$inboundSchema;
  /** @deprecated use `ReadRequest$outboundSchema` instead. */
  export const outboundSchema = ReadRequest$outboundSchema;
  /** @deprecated use `ReadRequest$Outbound` instead. */
  export type Outbound = ReadRequest$Outbound;
}

export function readRequestToJSON(readRequest: ReadRequest): string {
  return JSON.stringify(ReadRequest$outboundSchema.parse(readRequest));
}

export function readRequestFromJSON(
  jsonString: string,
): SafeParseResult<ReadRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReadRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReadRequest' from JSON`,
  );
}

/** @internal */
export const ReadResponse$inboundSchema: z.ZodType<
  ReadResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.ReadBatch$inboundSchema,
  z.instanceof(ReadableStream<Uint8Array>).transform(stream => {
    return new EventStream({
      stream,
      decoder(rawEvent) {
        const schema = components.ReadEvent$inboundSchema;
        return schema.parse(rawEvent);
      },
    });
  }),
]);

/** @internal */
export type ReadResponse$Outbound = components.ReadBatch$Outbound | never;

/** @internal */
export const ReadResponse$outboundSchema: z.ZodType<
  ReadResponse$Outbound,
  z.ZodTypeDef,
  ReadResponse
> = z.union([components.ReadBatch$outboundSchema, z.never()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReadResponse$ {
  /** @deprecated use `ReadResponse$inboundSchema` instead. */
  export const inboundSchema = ReadResponse$inboundSchema;
  /** @deprecated use `ReadResponse$outboundSchema` instead. */
  export const outboundSchema = ReadResponse$outboundSchema;
  /** @deprecated use `ReadResponse$Outbound` instead. */
  export type Outbound = ReadResponse$Outbound;
}

export function readResponseToJSON(readResponse: ReadResponse): string {
  return JSON.stringify(ReadResponse$outboundSchema.parse(readResponse));
}

export function readResponseFromJSON(
  jsonString: string,
): SafeParseResult<ReadResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReadResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReadResponse' from JSON`,
  );
}
