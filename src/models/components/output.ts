/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  SequencedRecordBatch,
  SequencedRecordBatch$inboundSchema,
  SequencedRecordBatch$Outbound,
  SequencedRecordBatch$outboundSchema,
} from "./sequencedrecordbatch.js";

/**
 * Sequence number for the next record on this stream, in case the requested `start_seq_num` was larger.
 *
 * @remarks
 * If returned in a streaming read session, this will be a terminal reply.
 */
export type NextSeqNum = {
  /**
   * Sequence number for the next record on this stream, in case the requested `start_seq_num` was larger.
   *
   * @remarks
   * If returned in a streaming read session, this will be a terminal reply.
   */
  nextSeqNum: number;
};

/**
 * Sequence number for the first record on this stream, in case the requested `start_seq_num` is smaller.
 *
 * @remarks
 * If returned in a streaming read session, this will be a terminal reply, to signal that there is uncertainty about whether some records may be omitted.
 * The client can re-establish the session starting at this sequence number.
 */
export type FirstSeqNum = {
  /**
   * Sequence number for the first record on this stream, in case the requested `start_seq_num` is smaller.
   *
   * @remarks
   * If returned in a streaming read session, this will be a terminal reply, to signal that there is uncertainty about whether some records may be omitted.
   * The client can re-establish the session starting at this sequence number.
   */
  firstSeqNum: number;
};

/**
 * Batch of records.
 *
 * @remarks
 * This batch can be empty only if a `ReadLimit` was provided in the associated read request, but the first record
 * that could have been returned would violate the limit.
 */
export type Batch = {
  /**
   * A batch of sequenced records.
   */
  batch: SequencedRecordBatch;
};

/**
 * Reply which can be a batch of records, or a sequence number if the request could not be satisfied.
 */
export type Output = Batch | FirstSeqNum | NextSeqNum;

/** @internal */
export const NextSeqNum$inboundSchema: z.ZodType<
  NextSeqNum,
  z.ZodTypeDef,
  unknown
> = z.object({
  next_seq_num: z.number().int(),
}).transform((v) => {
  return remap$(v, {
    "next_seq_num": "nextSeqNum",
  });
});

/** @internal */
export type NextSeqNum$Outbound = {
  next_seq_num: number;
};

/** @internal */
export const NextSeqNum$outboundSchema: z.ZodType<
  NextSeqNum$Outbound,
  z.ZodTypeDef,
  NextSeqNum
> = z.object({
  nextSeqNum: z.number().int(),
}).transform((v) => {
  return remap$(v, {
    nextSeqNum: "next_seq_num",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NextSeqNum$ {
  /** @deprecated use `NextSeqNum$inboundSchema` instead. */
  export const inboundSchema = NextSeqNum$inboundSchema;
  /** @deprecated use `NextSeqNum$outboundSchema` instead. */
  export const outboundSchema = NextSeqNum$outboundSchema;
  /** @deprecated use `NextSeqNum$Outbound` instead. */
  export type Outbound = NextSeqNum$Outbound;
}

export function nextSeqNumToJSON(nextSeqNum: NextSeqNum): string {
  return JSON.stringify(NextSeqNum$outboundSchema.parse(nextSeqNum));
}

export function nextSeqNumFromJSON(
  jsonString: string,
): SafeParseResult<NextSeqNum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NextSeqNum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NextSeqNum' from JSON`,
  );
}

/** @internal */
export const FirstSeqNum$inboundSchema: z.ZodType<
  FirstSeqNum,
  z.ZodTypeDef,
  unknown
> = z.object({
  first_seq_num: z.number().int(),
}).transform((v) => {
  return remap$(v, {
    "first_seq_num": "firstSeqNum",
  });
});

/** @internal */
export type FirstSeqNum$Outbound = {
  first_seq_num: number;
};

/** @internal */
export const FirstSeqNum$outboundSchema: z.ZodType<
  FirstSeqNum$Outbound,
  z.ZodTypeDef,
  FirstSeqNum
> = z.object({
  firstSeqNum: z.number().int(),
}).transform((v) => {
  return remap$(v, {
    firstSeqNum: "first_seq_num",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FirstSeqNum$ {
  /** @deprecated use `FirstSeqNum$inboundSchema` instead. */
  export const inboundSchema = FirstSeqNum$inboundSchema;
  /** @deprecated use `FirstSeqNum$outboundSchema` instead. */
  export const outboundSchema = FirstSeqNum$outboundSchema;
  /** @deprecated use `FirstSeqNum$Outbound` instead. */
  export type Outbound = FirstSeqNum$Outbound;
}

export function firstSeqNumToJSON(firstSeqNum: FirstSeqNum): string {
  return JSON.stringify(FirstSeqNum$outboundSchema.parse(firstSeqNum));
}

export function firstSeqNumFromJSON(
  jsonString: string,
): SafeParseResult<FirstSeqNum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FirstSeqNum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FirstSeqNum' from JSON`,
  );
}

/** @internal */
export const Batch$inboundSchema: z.ZodType<Batch, z.ZodTypeDef, unknown> = z
  .object({
    batch: SequencedRecordBatch$inboundSchema,
  });

/** @internal */
export type Batch$Outbound = {
  batch: SequencedRecordBatch$Outbound;
};

/** @internal */
export const Batch$outboundSchema: z.ZodType<
  Batch$Outbound,
  z.ZodTypeDef,
  Batch
> = z.object({
  batch: SequencedRecordBatch$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Batch$ {
  /** @deprecated use `Batch$inboundSchema` instead. */
  export const inboundSchema = Batch$inboundSchema;
  /** @deprecated use `Batch$outboundSchema` instead. */
  export const outboundSchema = Batch$outboundSchema;
  /** @deprecated use `Batch$Outbound` instead. */
  export type Outbound = Batch$Outbound;
}

export function batchToJSON(batch: Batch): string {
  return JSON.stringify(Batch$outboundSchema.parse(batch));
}

export function batchFromJSON(
  jsonString: string,
): SafeParseResult<Batch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Batch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Batch' from JSON`,
  );
}

/** @internal */
export const Output$inboundSchema: z.ZodType<Output, z.ZodTypeDef, unknown> = z
  .union([
    z.lazy(() => Batch$inboundSchema),
    z.lazy(() => FirstSeqNum$inboundSchema),
    z.lazy(() => NextSeqNum$inboundSchema),
  ]);

/** @internal */
export type Output$Outbound =
  | Batch$Outbound
  | FirstSeqNum$Outbound
  | NextSeqNum$Outbound;

/** @internal */
export const Output$outboundSchema: z.ZodType<
  Output$Outbound,
  z.ZodTypeDef,
  Output
> = z.union([
  z.lazy(() => Batch$outboundSchema),
  z.lazy(() => FirstSeqNum$outboundSchema),
  z.lazy(() => NextSeqNum$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Output$ {
  /** @deprecated use `Output$inboundSchema` instead. */
  export const inboundSchema = Output$inboundSchema;
  /** @deprecated use `Output$outboundSchema` instead. */
  export const outboundSchema = Output$outboundSchema;
  /** @deprecated use `Output$Outbound` instead. */
  export type Outbound = Output$Outbound;
}

export function outputToJSON(output: Output): string {
  return JSON.stringify(Output$outboundSchema.parse(output));
}

export function outputFromJSON(
  jsonString: string,
): SafeParseResult<Output, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Output$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Output' from JSON`,
  );
}
