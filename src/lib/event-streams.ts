/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export type ServerEvent<T> = {
  data?: T | undefined;
  event?: string | undefined;
  retry?: number | undefined;
  id?: string | undefined;
};
const LF = 0x0a;
const CR = 0x0d;
const NEWLINE_CHARS = new Set([LF, CR]);
const MESSAGE_BOUNDARIES = [
  new Uint8Array([CR, LF, CR, LF]),
  new Uint8Array([CR, CR]),
  new Uint8Array([LF, LF]),
];

export class EventStream<Event extends ServerEvent<unknown>> {
  private readonly stream: ReadableStream<Uint8Array>;
  private readonly decoder: (rawEvent: ServerEvent<string>) => Event;

  constructor(init: {
    stream: ReadableStream<Uint8Array>;
    decoder: (rawEvent: ServerEvent<string>) => Event;
  }) {
    this.stream = init.stream;
    this.decoder = init.decoder;
  }

  async *[Symbol.asyncIterator](): AsyncGenerator<Event, void, unknown> {
    const reader = this.stream.getReader();
    let buffer = new Uint8Array([]);
    let position = 0;

    try {
      while (true) {
        console.log("--------------await reader.read()------------------");
        // measure the time it takes to read the stream
        const start = Date.now();
        const { done, value } = await reader.read();
        const end = Date.now();
        console.log(`await reader.read() took: ${end - start}ms`);
        if (done) {
          break;
        }

        const newBuffer = new Uint8Array(buffer.length + value.length);
        newBuffer.set(buffer);
        newBuffer.set(value, buffer.length);
        buffer = newBuffer;

        for (let i = position; i < buffer.length; i++) {
          const boundary = findBoundary(buffer, i);
          if (boundary == null) {
            continue;
          }

          const chunk = buffer.slice(position, i);
          position = i + boundary.length;
          const event = parseEvent(chunk, this.decoder);
          if (event != null) {
            yield event;
          }
        }

        if (position > 0) {
          buffer = buffer.slice(position);
          position = 0;
        }
      }

      if (buffer.length > 0) {
        const event = parseEvent(buffer, this.decoder);
        if (event != null) {
          yield event;
        }
      }
    } catch (e: unknown) {
      if (e instanceof Error && e.name === "AbortError") {
        return;
      }

      throw e;
    } finally {
      reader.releaseLock();
    }
  }
}

function findBoundary(buffer: Uint8Array, start: number): Uint8Array | null {
  const char1 = buffer[start];
  const char2 = buffer[start + 1];

  // Don't bother checking if the first two characters are not new line
  // characters.
  if (
    char1 == null
    || char2 == null
    || !NEWLINE_CHARS.has(char1)
    || !NEWLINE_CHARS.has(char2)
  ) {
    return null;
  }

  for (const s of MESSAGE_BOUNDARIES) {
    const seq = peekSequence(start, buffer, s);
    if (seq != null) {
      return seq;
    }
  }

  return null;
}

function peekSequence(
  position: number,
  buffer: Uint8Array,
  sequence: Uint8Array,
): Uint8Array | null {
  if (sequence.length > buffer.length - position) {
    return null;
  }

  for (let i = 0; i < sequence.length; i++) {
    if (buffer[position + i] !== sequence[i]) {
      return null;
    }
  }

  return sequence;
}

function parseEvent<Event extends ServerEvent<unknown>>(
  chunk: Uint8Array,
  decoder: (rawEvent: ServerEvent<string>) => Event,
) {
  if (!chunk.length) {
    return null;
  }

  const td = new TextDecoder();
  const raw = td.decode(chunk);
  const lines = raw.split(/\r?\n|\r/g);
  let publish = false;
  const rawEvent: ServerEvent<string> = {};

  for (const line of lines) {
    if (!line) {
      continue;
    }

    const delim = line.indexOf(":");
    // Lines starting with a colon are ignored.
    if (delim === 0) {
      continue;
    }

    const field = delim > 0 ? line.substring(0, delim) : "";
    let value = delim > 0 ? line.substring(delim + 1) : "";
    if (value.charAt(0) === " ") {
      value = value.substring(1);
    }

    switch (field) {
      case "event": {
        publish = true;
        rawEvent.event = value;
        break;
      }
      case "data": {
        publish = true;
        rawEvent.data ??= "";
        rawEvent.data += value + "\n";
        break;
      }
      case "id": {
        publish = true;
        rawEvent.id = value;
        break;
      }
      case "retry": {
        const r = parseInt(value, 10);
        if (!Number.isNaN(r)) {
          publish = true;
          rawEvent.retry = r;
        }
        break;
      }
    }
  }

  if (!publish) {
    return null;
  }

  if (rawEvent.data != null) {
    rawEvent.data = rawEvent.data.slice(0, -1);
  }

  return decoder(rawEvent);
}

// export function discardSentinel(
//   source: ReadableStream<Uint8Array>,
//   sentinel: string
// ): ReadableStream<Uint8Array> {
//   // 1) Decode bytes → strings
//   const decoded = source.pipeThrough(new TextDecoderStream());

//   let buffer = "";

//   // 2) Transform: split on SSE double-newlines, drop everything after sentinel
//   const filtered = decoded.pipeThrough(
//     new TransformStream<string, string>({
//       start() {
//         buffer = "";
//       },
//       transform(chunk, ctrl) {
//         buffer += chunk;

//         let boundaryIndex: number;
//         // SSE messages end with \r\n\r\n (or variations); normalize to \n\n
//         // so we split on \n\n for simplicity
//         while ((boundaryIndex = buffer.indexOf("\n\n")) !== -1) {
//           const rawMsg = buffer.slice(0, boundaryIndex);
//           buffer = buffer.slice(boundaryIndex + 2);

//           // If this message contains the sentinel, emit only up to it and then terminate
//           if (rawMsg.includes(`data: ${sentinel}`)) {
//             // emit everything before sentinel
//             const before = rawMsg
//               .split("\n")
//               .filter((l) => !l.startsWith("data: " + sentinel))
//               .join("\n");
//             if (before) ctrl.enqueue(before + "\n\n");
//             ctrl.terminate();
//             return;
//           }

//           // otherwise, pass it through
//           ctrl.enqueue(rawMsg + "\n\n");
//         }
//       },
//       flush(ctrl) {
//         // any trailing partial chunk
//         if (buffer) {
//           ctrl.enqueue(buffer);
//         }
//       },
//     })
//   );

//   // 3) Re-encode strings → bytes
//   return filtered.pipeThrough(new TextEncoderStream());
// }

// export function discardSentinel(
//   stream: ReadableStream<Uint8Array>,
//   sentinel: string,
// ): ReadableStream<Uint8Array> {
//   const sentinelBytes = new TextEncoder().encode(sentinel);

//   // Helper to concatenate two Uint8Arrays
//   function concat(a: Uint8Array, b: Uint8Array): Uint8Array {
//     const c = new Uint8Array(a.length + b.length);
//     c.set(a, 0);
//     c.set(b, a.length);
//     return c;
//   }

//   // Helper to find needle in haystack starting at fromIndex
//   function indexOfBytes(
//     haystack: Uint8Array,
//     needle: Uint8Array,
//     fromIndex = 0,
//   ): number {
//     outer: for (let i = fromIndex; i <= haystack.length - needle.length; i++) {
//       for (let j = 0; j < needle.length; j++) {
//         if (haystack[i + j] !== needle[j]) continue outer;
//       }
//       return i;
//     }
//     return -1;
//   }

//   return new ReadableStream<Uint8Array>({
//     async start(controller) {
//       const reader = stream.getReader();
//       let tail: Uint8Array<ArrayBufferLike> = new Uint8Array(0);

//       try {
//         while (true) {
//           const { value, done } = await reader.read();
//           if (done) break;

//           // Combine leftover tail with new chunk
//           const combined = concat(tail, value);
//           let cursor = 0;

//           // Scan for all sentinel occurrences
//           let idx: number;
//           while ((idx = indexOfBytes(combined, sentinelBytes, cursor)) !== -1) {
//             // Enqueue data before the sentinel
//             const segment = combined.subarray(cursor, idx);
//             if (segment.length > 0) controller.enqueue(segment);
//             cursor = idx + sentinelBytes.length;
//           }

//           // After last sentinel, keep a tail that might be partial sentinel
//           const remaining = combined.subarray(cursor);
//           if (remaining.length > sentinelBytes.length) {
//             controller.enqueue(
//               remaining.subarray(0, remaining.length - sentinelBytes.length),
//             );
//             tail = remaining.subarray(remaining.length - sentinelBytes.length);
//           } else {
//             tail = remaining;
//           }
//         }

//         // Enqueue any leftover bytes (they can't form a full sentinel)
//         if (tail.length > 0) controller.enqueue(tail);
//         controller.close();
//       } catch (err) {
//         controller.error(err);
//       } finally {
//         reader.releaseLock();
//       }
//     },
//   });
// }

export function discardSentinel(
  stream: ReadableStream<Uint8Array>,
  sentinel: string,
): ReadableStream<Uint8Array> {
  return new ReadableStream<Uint8Array>({
    async start(controller) {
      let buffer = new Uint8Array([]);
      let position = 0;
      let done = false;
      let discard = false;
      const rdr = stream.getReader();
      try {
        while (!done) {
          const start = Date.now();
          console.log("---outer loop await rdr.read()---");
          const result = await rdr.read();
          const end = Date.now();
          console.log(`---outer loop await rdr.read() done--- ${end - start}ms`, result.done);
          const value = result.value;
          done = done || result.done;
          // We keep consuming from the source to its completion so it can
          // flush all its contents and release resources.
          if (discard) {
            console.log("discarding");
            continue;
          }
          if (typeof value === "undefined") {
            console.log(">>>undefined");
            continue;
          }

          const newBuffer = new Uint8Array(buffer.length + value.length);
          newBuffer.set(buffer);
          newBuffer.set(value, buffer.length);
          buffer = newBuffer;

          for (let i = position; i < buffer.length; i++) {
            const boundary = findBoundary(buffer, i);
            if (boundary == null) {
              // console.log(">>no boundary");
              continue;
            }

            const start = position;
            const chunk = buffer.slice(start, i);
            position = i + boundary.length;
            const event = parseEvent(chunk, id);
            if (event?.data === sentinel) {
              const asString = new TextDecoder().decode(buffer.slice(0, start));
              console.log(">>enqueuing str: discard", asString);
              controller.enqueue(buffer.slice(0, start));
              discard = true;
            } else {
              const asString = new TextDecoder().decode(buffer.slice(0, position));
              console.log(">>enqueuing str: ", asString);
              controller.enqueue(buffer.slice(0, position));
              buffer = buffer.slice(position);
              position = 0;
            }
          }
        }
      } catch (e) {
        controller.error(e);
      } finally {
        // If the source stream terminates, flush its contents and terminate.
        // If the sentinel event was found, flush everything up to its start.
        console.log("---finally close controller---");
        controller.close();
        rdr.releaseLock();
      }
    },
  });
}

function id<T>(v: T): T {
  return v;
}
